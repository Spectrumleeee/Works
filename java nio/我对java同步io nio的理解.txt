1、java阻塞socket,serversocket
  相当于服务器端直接维护与多个客户端的连接，如果服务器端只是用单线程，就必须轮询每个连接是否有数据可读，效率低下，并且accept等操作都是阻塞的，就是说必须等待接收到一个连接或者一个连接完成读和写操作才能继续下去处理宁外一个操作，这时候就想到了多线程，肯定比单线程要好，就是一个阻塞了，系统就会调度宁外一个线程运行，从而提高了资源的利用率，但是过多的线程不仅会占用资源，而且线程的创建和消除以及线程之间的调度也会消耗很多时间，这时就有各种线程池方案，通过线程池实现线程的复用，从而提高性能，否则一个一个连接创建一个线程效率低下，不现实。

2、既然多线程（线程池）和java nio都可以实现服务多个客户端，如何抉择。
  多线程 适用情况：【并发不高，数据量大或者频繁，长连接】如果是并发度不高，但个体吞吐量大或者说频密，那么用多线程模型比较好，这样每个连接都有专属线程，但是需要一直维护这些连接。
  NIO 适用情况：【并发高，数据量不大或稀疏（AIO），短连接】NIO的异步非阻塞的形式，使得很少的线程就能服务于大量的请求。通过Selector的注册功能，可以有选择性地返回已经准备好的频道，这样就不需要为每一个请求分配单独的线程来服务。也就是先把连接和可能的读写accept操作注册到selector上，然后就不需要线程来一直维护这些连接了，知道这个连接上有在selector上面注册的事件发生，selector就会使用一个线程来处理。

3、SocketChannel.closed()问题
  客户端请求连接服务端，服务端接受连接，并读取客户端发送的数据后，写入一些数据到SocketChannel之后，服务端就调用SocketChannel.close（）来关闭与客户端之间的SocketChannel通道，但是在客户端调用SocketChannel.isConnected()时候返回的是true,通道中有数据，及时等客户端读取完成SocketChannel中的最后数据，再调用SocketChannel.isConnected()时候，依旧返回的是true.